/* character.c – Our modB Driver code */

// Reference - http://www.opensourceforu.com/page/2/?s=drivers
#include <linux/module.h>
#include <linux/version.h>
#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <asm/uaccess.h>
 

#define XKTTY_MAX_PATH 20
#define XKTTY_NUM 0
#define XKTTY_MAX_BUF_LEN 200
 // tail -f /var/log/syslog - use this to view the messages

/*

A simple cat can be done as read operation - request to read
echo can be considered as a request to write operation

*/


 //A static variable inside a function keeps its value between invocations.

static dev_t modB; // Global variable for the modB device number 
static struct cdev c_dev; // Global variable for the character device structure
static struct class *cl; // Global variable for the device class
DEFINE_MUTEX(xmutex);

static struct file *xktty = NULL;


static int xktty_open(struct inode *inode, struct file *filp)
{

    char filename[XKTTY_MAX_PATH];
    /* only one process at a time */
    if(!(mutex_trylock(&xmutex)))
        return -EBUSY;

    snprintf(filename, XKTTY_MAX_PATH, "/dev/ttyS%d", XKTTY_NUM);
    xktty = (struct file *)ktty_open(filename, 0, O_RDWR);
    if (PTR_RET(xktty)) {
        mutex_unlock(&xmutex);
        return PTR_RET(xktty);
    }

    return 0;
}


static void ktty_close(struct file *xktty, fl_owner_t id)
{
        filp_close(xktty, id);
}

static int xktty_release(struct inode *inode, struct file *file)
{
    if(!IS_ERR_OR_NULL(xktty))
        ktty_close(xktty, 0);
    mutex_unlock(&xmutex);
    return 0;
}

static ssize_t ktty_write(struct file *f, const char *buf, int count)
{

    int result;
    mm_segment_t oldfs;

    oldfs = get_fs();
    set_fs(KERNEL_DS);
    f->f_pos = 0;
    result = f->f_op->write(f, buf, count, &f->f_pos);
    set_fs(oldfs);

    return result;
}


static ssize_t xktty_write(struct file *filp,
                           const char __user * buf, 
                           size_t count,
                           loff_t * f_pos)
{

    
    const char kbuf[XKTTY_MAX_BUF_LEN];

    count = count < XKTTY_MAX_BUF_LEN ? count : XKTTY_MAX_BUF_LEN;
    if (copy_from_user((char *)kbuf, (const char __user *)buf, count))
        return -EFAULT;

    if (!IS_ERR_OR_NULL(xktty))
        return ktty_write(xktty, kbuf, count);
    else
        return -EFAULT;
}

static ssize_t ktty_read(struct file *f, char *buf, int count)
{

    int result;
    mm_segment_t oldfs;

    oldfs = get_fs();
    set_fs(KERNEL_DS);
    f->f_pos = 0;
    result = f->f_op->read(f, buf, count, &f->f_pos);
    set_fs(oldfs);

    return result;
}

static ssize_t xktty_read(struct file *filp,
                           char __user * buf, 
                           size_t count,
                           loff_t * f_pos)
{

    
    char kbuf[XKTTY_MAX_BUF_LEN];

    count = count < XKTTY_MAX_BUF_LEN ? count : XKTTY_MAX_BUF_LEN;
    if (copy_to_user((char *)kbuf, (char __user *)buf, count))
        return -EFAULT;

    if (!IS_ERR_OR_NULL(xktty))
        return ktty_read(xktty, kbuf, count);
    else
        return -EFAULT;
}



  static struct file_operations modBus_fops =
{
  .owner = THIS_MODULE,
  .open = xktty_open,
  .release = xktty_release,
  .read = xktty_read,
  .write = xktty_write
};
 

static int __init modB_init(void) /* Constructor */
{
	if (alloc_chrdev_region(&modB, 0, 3, "abel") < 0) 
  // Get the major and minor number dynamically - " " is the device name, here abel 
    {
        return -1;
    }

    if ((cl = class_create(THIS_MODULE, "chardrv")) == NULL) 
    // Create a character driver class 
	{
	    unregister_chrdev_region(modB, 1); 
	    // This function will unregister a range of count device numbers, starting with from
      // /sys/class
	    return -1;
	}


	if (device_create(cl, NULL, modB, NULL, "modBus") == NULL) 
  // create device file  /dev/modBus
    {
	    class_destroy(cl);
	    unregister_chrdev_region(modB, 1);
	    return -1;
    }

    cdev_init(&c_dev, &modBus_fops); // initialize a cdev structure
    // Initializes cdev, remembering fops, making it ready to add to the system with cdev_add.

    if (cdev_add(&c_dev, modB, 1) == -1) 
    //cdev_add — add a char device to the system
    {
	    device_destroy(cl, modB);
	    class_destroy(cl);
	    unregister_chrdev_region(modB, 1);
	    return -1;
    }
    printk(KERN_INFO "<Major, Minor>: <%d, %d>\n", MAJOR(modB), MINOR(modB)); 
    // check cat /proc/devices for the registered device also ls /dev for registered device file
    printk(KERN_INFO "Hello World\n");
    return 0;
}
 
static void __exit modB_exit(void) /* Destructor */
{
    cdev_del(&c_dev);
    device_destroy(cl, modB);
	  class_destroy(cl);
	  unregister_chrdev_region(modB, 1);
    printk(KERN_INFO "I am Dead\n");
}
 
module_init(modB_init);
module_exit(modB_exit);
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Abel Paul Babu");
MODULE_DESCRIPTION("t1");


/*

The connection between the application and the device file is based on the name of the device file. However, 
the connection between the device file and the device driver is based on the number of the device file, not 
the name. This allows a user-space application to have any name for the device file, and enables the kernel-space 
to have a trivial index-based linkage between the device file and the device driver. This device file number is 
more commonly referred to as the <major, minor> pair, or the major and minor numbers of the device file.

*/





/*



1. Application
2. Character device file
3. Character device driver
4. Character device


 major and minor number connect the application and the character device file
 file to driver connection is done by linking the functions.

*/